<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Last Hope</title>
  <style>
    :root {
      color-scheme: dark;
    }
    body {
      margin: 0;
      background: #05050b;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      font-family: 'Trebuchet MS', 'Segoe UI', sans-serif;
    }
    canvas {
      border: 3px solid #111423;
      border-radius: 14px;
      background: #1a1a24;
      box-shadow: 0 0 40px rgba(0, 255, 255, 0.13);
      image-rendering: pixelated;
    }
  </style>
</head>
<body>
  <canvas id="game" width="1100" height="720"></canvas>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;
    const FPS = 60;
    const FLOOR = HEIGHT - 120;
    const MAX_ENEMIES = 50;

    const colors = {
      dark: '#1a1a22',
      mid: '#2c2c3a',
      light: '#474758',
      neonPink: '#ff69b4',
      neonBlue: '#77e9ff',
      coin: '#fed552',
      heat: '#ffb478'
    };

      const runFrameUrls = [
        'https://hc-cdn.hel1.your-objectstorage.com/s/v3/f057b96cf4eb7524649475deb1bbbced63d2eb98_soldier_1_run_0.png',
        'https://hc-cdn.hel1.your-objectstorage.com/s/v3/09bf02bfc958869332475e95ecd3d7265c1bcc84_soldier_1_run_1.png',
        'https://hc-cdn.hel1.your-objectstorage.com/s/v3/82a8d5787e38e0c352ed74bd632d36ad0fdcf7b8_soldier_1_run_2.png',
        'https://hc-cdn.hel1.your-objectstorage.com/s/v3/56f714d56382ef375f13214ca791470829918637_soldier_1_run_3.png',
        'https://hc-cdn.hel1.your-objectstorage.com/s/v3/b8352c549f3f1a024ddc265addf418c90417f5fc_soldier_1_run_4.png',
        'https://hc-cdn.hel1.your-objectstorage.com/s/v3/994f529461a49160bedce52d3371a880061b4b5b_soldier_1_run_5.png',
        'https://hc-cdn.hel1.your-objectstorage.com/s/v3/162c9e48d68400f14ad288a4cfd6a76b079ee7c1_soldier_1_run_6.png',
        'https://hc-cdn.hel1.your-objectstorage.com/s/v3/1fb637127c1d8cbe3723c36097bef3d10117c300_soldier_1_run_7.png'
      ];
    const idleUrls = [
      'https://hc-cdn.hel1.your-objectstorage.com/s/v3/b07b165b7875977d4f1096a85ecf248e4cf48694_soldier_1_idle_0.png',
      'https://hc-cdn.hel1.your-objectstorage.com/s/v3/da06c835f73716e3874a76a6a0e64917f0524fd0_soldier_1_idle_1.png',
      'https://hc-cdn.hel1.your-objectstorage.com/s/v3/a2d13e828d3f3a923d8967b616fd65b95413fc5b_soldier_1_idle_2.png',
      'https://hc-cdn.hel1.your-objectstorage.com/s/v3/39c56624ff3d9ad9049a8700e4f30d5b8b189bb9_soldier_1_idle_3.png',
      'https://hc-cdn.hel1.your-objectstorage.com/s/v3/872a4296963746f2e8afe0a8dd91a15b91f8fb62_soldier_1_idle_4.png'
    ];
    const deadUrls = [
      'https://hc-cdn.hel1.your-objectstorage.com/s/v3/f6c30ae20c0f193e59f5528702199b02688fc8c1_soldier_1_dead_0.png',
      'https://hc-cdn.hel1.your-objectstorage.com/s/v3/e6da5d24c3be03a76c7312c65ecca4b58d27fab6_soldier_1_dead_1.png',
      'https://hc-cdn.hel1.your-objectstorage.com/s/v3/df526838de595b128df317ede0f338798ecbf5a4_soldier_1_dead_2.png',
      'https://hc-cdn.hel1.your-objectstorage.com/s/v3/0f003e13cd031bf24f849762fc7e230edc3bab2b_soldier_1_dead_3.png',
      'https://hc-cdn.hel1.your-objectstorage.com/s/v3/079a039558a508800f76b8e836ec2c8e0787ecef_soldier_1_dead_4.png',
      'https://hc-cdn.hel1.your-objectstorage.com/s/v3/493090514e844022e58b133f2e370396e0246662_soldier_1_dead_5.png',
      'https://hc-cdn.hel1.your-objectstorage.com/s/v3/5c79de358501de568a1c4ac77f80e888ba9af587_soldier_1_dead_6.png',
      'https://hc-cdn.hel1.your-objectstorage.com/s/v3/5c79de358501de568a1c4ac77f80e888ba9af587_soldier_1_dead_7.png'
    ];
    const reloadUrls = [
      'https://hc-cdn.hel1.your-objectstorage.com/s/v3/26d7bf5787f6b216cfc993955c7d79238b975df3_soldier_1_reload_0.png',
      'https://hc-cdn.hel1.your-objectstorage.com/s/v3/6a3e4fa7c015229738da03854105bc23cb270341_soldier_1_reload_1.png',
      'https://hc-cdn.hel1.your-objectstorage.com/s/v3/eab6c52f42262b134687ee203c8cb81b1418659d_soldier_1_reload_2.png',
      'https://hc-cdn.hel1.your-objectstorage.com/s/v3/bfa8d7c23f6f91ba3f5ec9fef39d06b6104fb166_soldier_1_reload_3.png',
      'https://hc-cdn.hel1.your-objectstorage.com/s/v3/14fe6a2512d7f163b2ec0ae892ee0ad68ee38ce3_soldier_1_reload_4.png',
      'https://hc-cdn.hel1.your-objectstorage.com/s/v3/3b80193640c51a07f30e49b4282747f13f7842bb_soldier_1_reload_5.png'
    ];
    const shootUrls = [
      'https://hc-cdn.hel1.your-objectstorage.com/s/v3/d0740585aa0dd41cb72e4d06c4c720cc903c5691_soldier_1_shot_0.png',
      'https://hc-cdn.hel1.your-objectstorage.com/s/v3/b07b165b7875977d4f1096a85ecf248e4cf48694_soldier_1_shot_1.png'
    ];
    const PLAYER_SCALE = 3;
    let runSpriteRadius = 24 * PLAYER_SCALE;
    let state;
    const updateRadiusFromFrame = (() => {
      let initialized = false;
      return (img) => {
        if (initialized || !img.width || !img.height) return;
        initialized = true;
        const minDim = Math.min(img.width, img.height);
        runSpriteRadius = Math.round((minDim / 2) * PLAYER_SCALE * 0.6);
        if (state && state.player) {
          state.player.radius = runSpriteRadius;
        }
      };
    })();
    const loadFrames = (urls, onLoad) =>
      urls.map((url) => {
        const img = new Image();
        img.onload = () => onLoad?.(img);
        img.src = url;
        return img;
      });
    const SHOOT_ANIM_DURATION = 0.18;
    const ANIM_SPEEDS = {
      idle: 0.22,
      run: 0.08,
      reload: 0.12,
      death: 0.28,
      shoot: 0.12
    };
    const animationFrames = {
      idle: loadFrames(idleUrls, updateRadiusFromFrame),
      run: loadFrames(runFrameUrls, updateRadiusFromFrame),
      reload: loadFrames(reloadUrls),
      death: loadFrames(deadUrls),
      shoot: loadFrames(shootUrls)
    };

    const shopPool = [
      { name: 'heat sink', desc: 'vents faster cool down', cost: 6, effect: 'heatSink' },
      { name: 'side hustle', desc: '+1 shot damage', cost: 8, effect: 'damage' },
      { name: 'restock', desc: '+35 hp instantly', cost: 5, effect: 'heal' },
      { name: 'armor plating', desc: '+15 max hp (and heal)', cost: 7, effect: 'maxHealth' },
      { name: 'espresso skates', desc: '+45 move speed', cost: 6, effect: 'speed' },
      { name: 'trigger tweak', desc: 'faster fire rate', cost: 7, effect: 'fireRate' },
      { name: 'coin printer', desc: 'coins drop x2 value', cost: 10, effect: 'coinBonus' }
    ];

    const baseDialog = [
      'dear dystopia journal: Remote operations are still fishy', 
      'Programmed controls are WASD',
      'left mouse click is shoot',
      'press SPACE to start, END NAPOLEON'
    ];

    const keys = {};
    const mouse = { x: WIDTH / 2, y: HEIGHT / 2, down: false };

    function makePlayer() {
      return {
        pos: { x: WIDTH / 2, y: HEIGHT / 2 },
        radius: runSpriteRadius,
        speed: 360,
        maxHealth: 130,
        health: 130,
        heat: 0,
        dash: 0,
        damage: 1,
        coolRate: 0.8,
        fireDelay: 0.18,
        ammo: 10,
        maxAmmo: 10,
        isReloading: false,
        reloadTimer: 0,
        reloadTime: 1.5,
        animState: 'idle',
        animFrame: 0,
        animTimer: 0,
        animSpeeds: ANIM_SPEEDS,
        isMoving: false,
        facing: 1,
        shootTimer: 0,
        isDead: false,
        deathPlayed: false
      };
    }

    function makeShot(player, target) {
      // Can't shoot while cooling down, reloading, or out of ammo
      if (player.cool > 0 || player.isReloading || player.ammo <= 0) return null;
      
      let dx = target.x - player.pos.x;
      let dy = target.y - player.pos.y;
      const len = Math.hypot(dx, dy) || 1;
      dx /= len;
      dy /= len;
      
      const speed = 650 + player.heat * 30;
      
      player.cool = player.fireDelay;
      player.ammo--;
      player.shootTimer = SHOOT_ANIM_DURATION;
      
      // Auto realding stuff
      if (player.ammo <= 0) {
        player.isReloading = true;
        player.reloadTimer = player.reloadTime;
      }
      
      const spawnOffset = Math.min(player.radius + 8, 30);
      return {
        pos: {
          x: player.pos.x + dx * spawnOffset,
          y: player.pos.y + dy * spawnOffset
        },
        vel: { x: dx * speed, y: dy * speed },
        damage: player.damage,
        life: 1.3,
        radius: 6
      };
    }

    function makeEnemy(wave) {
      const pad = 80;
      const roll = Math.random();
      let edge = 'top';
      if (roll >= 0.25) {
        const pick = ['bottom', 'left', 'right'];
        edge = pick[Math.floor(Math.random() * pick.length)];
      }
      let pos = { x: 0, y: 0 };
      if (edge === 'top') {
        pos = { x: Math.random() * WIDTH, y: -pad };
      } else if (edge === 'bottom') {
        pos = { x: Math.random() * WIDTH, y: HEIGHT + pad };
      } else if (edge === 'left') {
        pos = { x: -pad, y: Math.random() * HEIGHT };
      } else {
        pos = { x: WIDTH + pad, y: Math.random() * HEIGHT };
      }
      return {
        pos,
        speed: randRange(100, 190) + wave * 7,
        hp: 2 + Math.floor(wave / 3),
        size: randInt(18, 32),
        mood: 0
      };
    }

    function makeCoin(position) {
      return {
        pos: { x: position.x, y: position.y },
        vel: { x: randRange(-120, 120), y: randRange(-260, -120) },
        value: Math.random() < 0.66 ? 1 : 2,
        radius: 10
      };
    }

    function makeState() {
      return {
        player: makePlayer(),
        shots: [],
        enemies: [],
        coins: [],
        spawnTimer: 0.5,
        wave: 1,
        score: 0,
        coinsBank: 0,
        menu: true,
        gameOver: false,
        shopActive: false,
        shopMessage: '',
        shopTimer: 20,
        shopCards: [],
        coinBonus: 1,
        shopNoteTimer: 0,
        dialog: baseDialog.slice()
      };
    }

    state = makeState();

    function randRange(min, max) {
      return Math.random() * (max - min) + min;
    }

    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function movePlayer(player, dt) {
      let dx = 0;
      let dy = 0;
      if (keys['KeyW'] || keys['ArrowUp']) dy -= 1;
      if (keys['KeyS'] || keys['ArrowDown']) dy += 1;
      if (keys['KeyA'] || keys['ArrowLeft']) dx -= 1;
      if (keys['KeyD'] || keys['ArrowRight']) dx += 1;
      const len = Math.hypot(dx, dy);
      const moving = len > 0;
      player.isMoving = moving;
      if (moving) {
        dx /= len;
        dy /= len;
        if (Math.abs(dx) > 0.01) {
          player.facing = dx > 0 ? 1 : -1;
        }
      }
      const dashSpeed = player.dash > 0 ? 1.65 : 1;
      player.pos.x += dx * player.speed * dashSpeed * dt;
      player.pos.y += dy * player.speed * dashSpeed * dt;
      player.pos.x = Math.max(player.radius, Math.min(WIDTH - player.radius, player.pos.x));
      player.pos.y = Math.max(player.radius, Math.min(FLOOR - player.radius, player.pos.y));
      player.cool = Math.max(0, player.cool - dt);
      player.heat = Math.max(0, player.heat - dt * player.coolRate);
      player.dash = Math.max(0, player.dash - dt);
    }

    function dashPlayer(player) {
      if (player.heat > 2.7 || player.dash > 0) return;
      player.dash = 0.3;
      player.heat = Math.min(4, player.heat + 0.5);
    }

    function updatePlayerAnimation(player, dt) {
      // reaload timer
      if (player.isReloading) {
        player.reloadTimer -= dt;
        if (player.reloadTimer <= 0) {
          player.ammo = player.maxAmmo;
          player.isReloading = false;
        }
      }
      
      player.shootTimer = Math.max(0, player.shootTimer - dt);
      
      // animation state
      let desiredState = 'idle';
      if (player.isDead && animationFrames.death.length) {
        desiredState = 'death';
      } else if (player.isReloading && animationFrames.reload.length) {
        desiredState = 'reload';
      } else if (player.shootTimer > 0 && animationFrames.shoot.length) {
        desiredState = 'shoot';
      } else if (player.isMoving && animationFrames.run.length) {
        desiredState = 'run';
      } else if (animationFrames.idle.length) {
        desiredState = 'idle';
      }
      if (player.animState !== desiredState) {
        player.animState = desiredState;
        player.animFrame = 0;
        player.animTimer = 0;
        if (desiredState === 'death') {
          player.deathPlayed = false;
        }
      }
      const frames = animationFrames[player.animState] && animationFrames[player.animState].length
        ? animationFrames[player.animState]
        : animationFrames.idle;
      if (!frames.length) return;
      const frameDuration = player.animSpeeds[player.animState] ?? 0.12;
      player.animTimer += dt;
      if (player.animState === 'death') {
        while (player.animTimer >= frameDuration && player.animFrame < frames.length - 1) {
          player.animTimer -= frameDuration;
          player.animFrame += 1;
        }
        if (player.animFrame >= frames.length - 1) {
          player.deathPlayed = true;
        }
        return;
      }
      while (player.animTimer >= frameDuration) {
        player.animTimer -= frameDuration;
        player.animFrame = (player.animFrame + 1) % frames.length;
      }
    }

    function updateShots(state, dt) {
      state.shots = state.shots.filter((shot) => {
        shot.pos.x += shot.vel.x * dt;
        shot.pos.y += shot.vel.y * dt;
        shot.life -= dt;
        return (
          shot.life > 0 &&
          shot.pos.x > -60 &&
          shot.pos.x < WIDTH + 60 &&
          shot.pos.y > -60 &&
          shot.pos.y < HEIGHT + 60
        );
      });
    }

    function updateEnemies(state, dt) {
      const target = state.player.pos;
      state.enemies.forEach((enemy) => {
        let dx = target.x - enemy.pos.x;
        let dy = target.y - enemy.pos.y;
        const len = Math.hypot(dx, dy) || 1;
        dx /= len;
        dy /= len;
        enemy.pos.x += dx * enemy.speed * dt;
        enemy.pos.y += dy * enemy.speed * dt;
        enemy.mood += dt * 3;
      });
    }

    function updateCoins(state, dt) {
      const player = state.player;
      for (let i = state.coins.length - 1; i >= 0; i--) {
        const coin = state.coins[i];
        coin.vel.y += 250 * dt;
        coin.pos.x += coin.vel.x * dt;
        coin.pos.y += coin.vel.y * dt;
        if (coin.pos.y > FLOOR - coin.radius) {
          coin.pos.y = FLOOR - coin.radius;
          coin.vel.y *= -0.25;
          coin.vel.x *= 0.75;
        }
        const dist = Math.hypot(coin.pos.x - player.pos.x, coin.pos.y - player.pos.y);
        if (dist < coin.radius + player.radius) {
          state.coinsBank += coin.value * state.coinBonus;
          state.coins.splice(i, 1);
          continue;
        }
        if (coin.pos.y >= FLOOR - coin.radius && Math.abs(coin.vel.y) < 5) {
          coin.vel.y = 0;
        }
      }
    }

    function spawnEnemy(state) {
      if (state.enemies.length >= MAX_ENEMIES) return;
      state.enemies.push(makeEnemy(state.wave));
    }

    function dropCoins(state, pos) {
      const count = randInt(1, 3);
      for (let i = 0; i < count; i++) {
        state.coins.push(makeCoin(pos));
      }
    }

    function handleCollisions(state, dt) {
      const player = state.player;
      for (let i = state.enemies.length - 1; i >= 0; i--) {
        const enemy = state.enemies[i];
        for (let j = state.shots.length - 1; j >= 0; j--) {
          const shot = state.shots[j];
          const dist = Math.hypot(enemy.pos.x - shot.pos.x, enemy.pos.y - shot.pos.y);
          if (dist < enemy.size + shot.radius) {
            enemy.hp -= shot.damage;
            state.shots.splice(j, 1);
            state.score += 6;
          }
        }
        if (enemy.hp <= 0) {
          state.enemies.splice(i, 1);
          state.score += 30;
          dropCoins(state, enemy.pos);
          continue;
        }
        const touch = Math.hypot(enemy.pos.x - player.pos.x, enemy.pos.y - player.pos.y) < enemy.size + player.radius;
        if (touch) {
          player.health -= 35 * dt;
          player.heat = Math.min(4, player.heat + 0.1 * dt * FPS);
        }
      }
      if (player.health <= 0 && !state.gameOver) {
        player.isDead = true;
        player.shootTimer = 0;
        state.gameOver = true;
        state.shopActive = false;
      }
    }

    function updateWaves(state, dt) {
      state.spawnTimer -= dt;
      if (state.spawnTimer <= 0) {
        spawnEnemy(state);
        state.spawnTimer = Math.max(0.45, 1.4 - state.wave * 0.08);
      }
      if (state.score > state.wave * 220) {
        state.wave += 1;
        state.player.health = Math.min(state.player.maxHealth, state.player.health + 20);
      }
      state.shopTimer -= dt;
      if (state.shopTimer <= 0 && !state.shopActive) {
        openShop(state);
      }
    }

    function tickNote(state, dt) {
      if (state.shopNoteTimer > 0) {
        state.shopNoteTimer = Math.max(0, state.shopNoteTimer - dt);
        if (state.shopNoteTimer === 0 && !state.shopActive) {
          state.shopMessage = '';
        }
      }
    }

    function openShop(state) {
      state.shopActive = true;
      state.shopMessage = 'shop paused reality';
      state.shopCards = pickShopCards(shopPool, Math.min(5, shopPool.length));
      state.shopNoteTimer = 0;
    }

    function closeShop(state) {
      state.shopActive = false;
      state.shopMessage = '';
      state.shopTimer = randRange(18, 28);
      state.shopCards = [];
      state.shopNoteTimer = 0;
    }

    function pickShopCards(pool, count) {
      const bag = pool.slice();
      const picks = [];
      while (picks.length < count && bag.length) {
        const idx = Math.floor(Math.random() * bag.length);
        picks.push(bag.splice(idx, 1)[0]);
      }
      return picks;
    }

    function buyOption(state, index) {
      if (index >= state.shopCards.length) {
        closeShop(state);
        return;
      }
      const card = state.shopCards[index];
      if (state.coinsBank < card.cost) {
        state.shopMessage = 'not enough coin juice';
        state.shopNoteTimer = 1.6;
        return;
      }
      state.coinsBank -= card.cost;
      applyUpgrade(state, card.effect);
      closeShop(state);
      state.shopMessage = `bought ${card.name}`;
      state.shopNoteTimer = 2.5;
    }

    function applyUpgrade(state, effect) {
      const player = state.player;
      if (effect === 'heatSink') player.coolRate += 0.25;
      else if (effect === 'damage') player.damage += 1;
      else if (effect === 'heal') player.health = Math.min(player.maxHealth, player.health + 35);
      else if (effect === 'maxHealth') {
        player.maxHealth += 15;
        player.health = Math.min(player.maxHealth, player.health + 15);
      } else if (effect === 'speed') player.speed += 45;
      else if (effect === 'fireRate') player.fireDelay = Math.max(0.08, player.fireDelay - 0.02);
      else if (effect === 'coinBonus') state.coinBonus += 1;
    }

    function updateGame(state, dt) {
      const player = state.player;
      
      // Handle player input and moveing
      movePlayer(player, dt);
      
      // Handle dashing
      if (keys['ShiftLeft'] || keys['ShiftRight']) {
        dashPlayer(player);
      }
      
      // Handle manual reload with 'R' key
      if (keys['KeyR'] && !player.isReloading && player.ammo < player.maxAmmo) {
        player.isReloading = true;
        player.reloadTimer = player.reloadTime;
      }
      
      // Update animations
      updatePlayerAnimation(player, dt);
      
      // Handle shooting
      const wantsShot = (mouse.down || keys['Space']) && !player.isReloading;
      if (wantsShot) {
        const shot = makeShot(player, mouse);
        if (shot) state.shots.push(shot);
      }
      
      // Update game systems
      updateShots(state, dt);
      updateEnemies(state, dt);
      handleCollisions(state, dt);
      updateCoins(state, dt);
      updateWaves(state, dt);
      tickNote(state, dt);
    }

    function drawBackground() {
      ctx.fillStyle = colors.dark;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = colors.mid;
      ctx.fillRect(0, FLOOR, WIDTH, HEIGHT - FLOOR);
      for (let i = 0; i < 7; i++) {
        const gap = 110;
        const baseX = (i * gap + (i % 2) * 30) % WIDTH;
        const buildingHeight = 120 + ((i * 27) % 180);
        ctx.fillStyle = colors.light;
        ctx.fillRect(baseX, FLOOR - buildingHeight, 70, buildingHeight);
        ctx.fillStyle = '#5a5a78';
        ctx.fillRect(baseX + 15, FLOOR - buildingHeight - 16, 40, 18);
      }
    }

    function drawPlayer() {
      const p = state.player;
      const frames = animationFrames[p.animState] && animationFrames[p.animState].length
        ? animationFrames[p.animState]
        : animationFrames.idle;
      if (frames && frames.length) {
        const frame = frames[p.animFrame % frames.length];
        const width = frame.width * PLAYER_SCALE;
        const height = frame.height * PLAYER_SCALE;
        ctx.save();
        ctx.translate(p.pos.x, p.pos.y);
        ctx.scale(p.facing, 1);
        ctx.drawImage(frame, -width / 2, -height / 2, width, height);
        ctx.restore();
      } else {
        ctx.beginPath();
        ctx.fillStyle = colors.neonBlue;
        ctx.arc(p.pos.x, p.pos.y, p.radius, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.beginPath();
      ctx.fillStyle = colors.neonPink;
      ctx.arc(p.pos.x, p.pos.y - p.radius + 4, 6, 0, Math.PI * 2);
      ctx.fill();
      if (p.dash > 0) {
        ctx.beginPath();
        ctx.strokeStyle = 'rgb(180,255,255)';
        ctx.lineWidth = 2;
        ctx.arc(p.pos.x, p.pos.y, p.radius, 0, Math.PI * 2);
        ctx.stroke();
      }
    }

    function drawEnemies() {
      state.enemies.forEach((enemy) => {
        const tint = Math.min(150, Math.floor(enemy.mood * 20));
        ctx.beginPath();
        ctx.fillStyle = `rgb(${Math.min(255, 120 + tint)}, 40, 60)`;
        ctx.arc(enemy.pos.x, enemy.pos.y, enemy.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.fillStyle = '#000';
        ctx.arc(enemy.pos.x, enemy.pos.y, 4, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawShots() {
      ctx.fillStyle = colors.neonPink;
      state.shots.forEach((shot) => {
        ctx.beginPath();
        ctx.arc(shot.pos.x, shot.pos.y, shot.radius, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawCoins() {
      state.coins.forEach((coin) => {
        ctx.beginPath();
        ctx.fillStyle = colors.coin;
        ctx.arc(coin.pos.x, coin.pos.y, coin.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.fillStyle = '#fff';
        ctx.arc(coin.pos.x, coin.pos.y, 4, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawHud() {
      const player = state.player;
      const barWidth = 200;
      const barHeight = 8;
      const spacing = 36;
      let yPos = 20;
      ctx.textAlign = 'left';
      ctx.font = '14px "Trebuchet MS", sans-serif';
      ctx.fillStyle = 'white';

      const drawBar = (label, ratio, fillColor) => {
        ctx.fillStyle = colors.dark;
        ctx.fillRect(20, yPos + 12, barWidth, barHeight);
        ctx.fillStyle = fillColor;
        ctx.fillRect(20, yPos + 12, Math.max(0, Math.min(1, ratio)) * barWidth, barHeight);
        ctx.fillStyle = 'white';
        ctx.fillText(label, 20, yPos + 10);
        yPos += spacing;
      };

      drawBar(
        `HP: ${Math.ceil(player.health)}/${player.maxHealth}`,
        player.health / player.maxHealth,
        colors.neonPink
      );

      let ammoText = `AMMO: ${player.ammo}/${player.maxAmmo}`;
      if (player.isReloading) {
        const reloadProgress = 1 - player.reloadTimer / player.reloadTime;
        ammoText += ` (RELOADING ${Math.ceil(reloadProgress * 100)}%)`;
      }
      drawBar(ammoText, player.ammo / player.maxAmmo, colors.neonBlue);

      drawBar(`HEAT: ${player.heat.toFixed(1)}/4`, player.heat / 4, colors.heat);

      ctx.textAlign = 'right';
      ctx.fillStyle = 'white';
      ctx.fillText(`SCORE: ${state.score}`, WIDTH - 20, 30);
      ctx.fillText(`WAVE: ${state.wave}`, WIDTH - 20, 50);
      ctx.fillStyle = colors.coin;
      ctx.fillText(`COINS: ${state.coinsBank}`, WIDTH - 20, 70);

      if (player.ammo < player.maxAmmo / 2 && !player.isReloading) {
        ctx.fillStyle = 'yellow';
        ctx.textAlign = 'center';
        ctx.fillText('Press R to reload', WIDTH / 2, HEIGHT - 30);
      }
    }

    function drawMenu() {
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = colors.neonBlue;
      ctx.font = '54px "Trebuchet MS", sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('LAST HOPE', WIDTH / 2, 180);
      ctx.fillStyle = '#e6e6e6';
      ctx.font = '26px "Trebuchet MS", sans-serif';
      state.dialog.forEach((line, idx) => {
        ctx.fillText(line, WIDTH / 2, 260 + idx * 40);
      });
      ctx.textAlign = 'left';
    }

    function drawGameOver() {
      ctx.fillStyle = 'rgba(5,5,12,0.75)';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = colors.heat;
      ctx.font = '60px "Trebuchet MS", sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('system failure', WIDTH / 2, HEIGHT / 2 - 20);
      ctx.fillStyle = '#fff';
      ctx.font = '28px "Trebuchet MS", sans-serif';
      ctx.fillText('Refresh the page to play again', WIDTH / 2, HEIGHT / 2 + 30);
      ctx.textAlign = 'left';
    }

    function drawShop() {
      const cards = state.shopCards;
      const optionCount = cards.length;
      const panelWidth = 520;
      const panelHeight = 70 + optionCount * 60;
      let px = state.player.pos.x - panelWidth / 2;
      px = Math.max(40, Math.min(WIDTH - panelWidth - 40, px));
      let py = Math.max(80, state.player.pos.y - state.player.radius - panelHeight - 20);
      ctx.fillStyle = 'rgba(30,30,40,0.95)';
      ctx.fillRect(px, py, panelWidth, panelHeight);
      ctx.strokeStyle = colors.neonBlue;
      ctx.lineWidth = 3;
      ctx.strokeRect(px, py, panelWidth, panelHeight);
      ctx.fillStyle = '#fff';
      ctx.font = '22px "Trebuchet MS", sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(`pop-up shop: pick (1-${optionCount}) or skip (${optionCount + 1})`, px + panelWidth / 2, py + 30);
      cards.forEach((card, idx) => {
        const affordable = state.coinsBank >= card.cost;
        ctx.fillStyle = affordable ? 'rgb(200,255,220)' : 'rgb(130,130,130)';
        ctx.fillText(`${idx + 1}) ${card.name} [${card.cost}c]`, px + panelWidth / 2, py + 60 + idx * 60);
        ctx.fillStyle = 'rgb(180,180,200)';
        ctx.font = '18px "Trebuchet MS", sans-serif';
        ctx.fillText(card.desc, px + panelWidth / 2, py + 84 + idx * 60);
        ctx.font = '22px "Trebuchet MS", sans-serif';
      });
      ctx.fillStyle = '#fff';
      ctx.fillText(`${optionCount + 1}) close shop`, px + panelWidth / 2, py + panelHeight - 24);
      ctx.textAlign = 'left';
    }

    function draw() {
      drawBackground();
      drawCoins();
      drawEnemies();
      drawShots();
      drawPlayer();
      drawHud();
      if (state.menu) drawMenu();
      if (state.shopActive) drawShop();
      if (state.gameOver) drawGameOver();
    }

    window.addEventListener('keydown', (e) => {
      if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
        e.preventDefault();
      }
      if (!e.repeat) keys[e.code] = true;
      if (e.code === 'Space' && state.menu) {
        state.menu = false;
      }
      if (state.shopActive) {
        if (/^[0-9]$/.test(e.key)) {
          const choice = parseInt(e.key, 10);
          if (choice >= 1 && choice <= state.shopCards.length) {
            buyOption(state, choice - 1);
          } else if (choice === state.shopCards.length + 1) {
            closeShop(state);
          }
        }
        if (e.code === 'Enter' || e.code === 'Escape' || e.code === 'NumpadEnter') {
          closeShop(state);
        }
      }
    });

    window.addEventListener('keyup', (e) => {
      keys[e.code] = false;
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * WIDTH;
      mouse.y = ((e.clientY - rect.top) / rect.height) * HEIGHT;
    });

    canvas.addEventListener('mousedown', (e) => {
      mouse.down = true;
      if (state.menu) state.menu = false;
    });

    window.addEventListener('mouseup', () => {
      mouse.down = false;
    });

    canvas.addEventListener('mouseleave', () => {
      mouse.down = false;
    });

    let last = performance.now();
    function loop(now) {
      const dt = Math.min(0.05, (now - last) / 1000);
      last = now;
      if (!state.menu && !state.gameOver && !state.shopActive) {
        updateGame(state, dt);
      }
      if (!state.menu) {
        updatePlayerAnimation(state.player, dt);
      }
      draw();
      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
