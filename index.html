<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Last Hope</title>
  <style>
    :root {
      color-scheme: dark;
    }
    body {
      margin: 0;
      background: #05050b;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      font-family: 'Trebuchet MS', 'Segoe UI', sans-serif;
    }
    canvas {
      border: 3px solid #111423;
      border-radius: 14px;
      background: #1a1a24;
      box-shadow: 0 0 40px rgba(0, 255, 255, 0.13);
      image-rendering: pixelated;
    }
  </style>
</head>
<body>
  <canvas id="game" width="1100" height="720"></canvas>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;
    const FPS = 60;
    const FLOOR = HEIGHT - 120;
    const MAX_ENEMIES = 50;

    const colors = {
      dark: '#1a1a22',
      mid: '#2c2c3a',
      light: '#474758',
      neonPink: '#ff69b4',
      neonBlue: '#77e9ff',
      coin: '#fed552',
      heat: '#ffb478'
    };

    const shopPool = [
      { name: 'heat sink', desc: 'vents faster cool down', cost: 6, effect: 'heatSink' },
      { name: 'side hustle', desc: '+1 shot damage', cost: 8, effect: 'damage' },
      { name: 'restock', desc: '+35 hp instantly', cost: 5, effect: 'heal' },
      { name: 'armor plating', desc: '+15 max hp (and heal)', cost: 7, effect: 'maxHealth' },
      { name: 'espresso skates', desc: '+45 move speed', cost: 6, effect: 'speed' },
      { name: 'trigger tweak', desc: 'faster fire rate', cost: 7, effect: 'fireRate' },
      { name: 'coin printer', desc: 'coins drop x2 value', cost: 10, effect: 'coinBonus' }
    ];

    const baseDialog = [
      'dear dystopia journal: Remote operations are still fishy', 
      'Programmed controls are WASD',
      'left mouse click is shoot',
      'press SPACE to start, END NAPOLEON'
    ];

    const keys = {};
    const mouse = { x: WIDTH / 2, y: HEIGHT / 2, down: false };

    function makePlayer() {
      return {
        pos: { x: WIDTH / 2, y: HEIGHT / 2 },
        radius: 24,
        speed: 360,
        maxHealth: 130,
        health: 130,
        cool: 0,
        heat: 0,
        dash: 0,
        damage: 1,
        coolRate: 0.8,
        fireDelay: 0.18
      };
    }

    function makeShot(player, target) {
      if (player.cool > 0 || player.heat >= 3) return null;
      let dx = target.x - player.pos.x;
      let dy = target.y - player.pos.y;
      const len = Math.hypot(dx, dy) || 1;
      dx /= len;
      dy /= len;
      const speed = 650 + player.heat * 40;
      player.cool = player.fireDelay;
      player.heat = Math.min(4, player.heat + 0.32);
      return {
        pos: { x: player.pos.x, y: player.pos.y },
        vel: { x: dx * speed, y: dy * speed },
        damage: player.damage,
        life: 1.3,
        radius: 6
      };
    }

    function makeEnemy(wave) {
      const pad = 80;
      const roll = Math.random();
      let edge = 'top';
      if (roll >= 0.25) {
        const pick = ['bottom', 'left', 'right'];
        edge = pick[Math.floor(Math.random() * pick.length)];
      }
      let pos = { x: 0, y: 0 };
      if (edge === 'top') {
        pos = { x: Math.random() * WIDTH, y: -pad };
      } else if (edge === 'bottom') {
        pos = { x: Math.random() * WIDTH, y: HEIGHT + pad };
      } else if (edge === 'left') {
        pos = { x: -pad, y: Math.random() * HEIGHT };
      } else {
        pos = { x: WIDTH + pad, y: Math.random() * HEIGHT };
      }
      return {
        pos,
        speed: randRange(100, 190) + wave * 7,
        hp: 2 + Math.floor(wave / 3),
        size: randInt(18, 32),
        mood: 0
      };
    }

    function makeCoin(position) {
      return {
        pos: { x: position.x, y: position.y },
        vel: { x: randRange(-120, 120), y: randRange(-260, -120) },
        value: Math.random() < 0.66 ? 1 : 2,
        radius: 10
      };
    }

    function makeState() {
      return {
        player: makePlayer(),
        shots: [],
        enemies: [],
        coins: [],
        spawnTimer: 0.5,
        wave: 1,
        score: 0,
        coinsBank: 0,
        menu: true,
        gameOver: false,
        shopActive: false,
        shopMessage: '',
        shopTimer: 20,
        shopCards: [],
        coinBonus: 1,
        shopNoteTimer: 0,
        dialog: baseDialog.slice()
      };
    }

    let state = makeState();

    function randRange(min, max) {
      return Math.random() * (max - min) + min;
    }

    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function movePlayer(player, dt) {
      let dx = 0;
      let dy = 0;
      if (keys['KeyW'] || keys['ArrowUp']) dy -= 1;
      if (keys['KeyS'] || keys['ArrowDown']) dy += 1;
      if (keys['KeyA'] || keys['ArrowLeft']) dx -= 1;
      if (keys['KeyD'] || keys['ArrowRight']) dx += 1;
      const len = Math.hypot(dx, dy);
      if (len > 0) {
        dx /= len;
        dy /= len;
      }
      const dashSpeed = player.dash > 0 ? 1.65 : 1;
      player.pos.x += dx * player.speed * dashSpeed * dt;
      player.pos.y += dy * player.speed * dashSpeed * dt;
      player.pos.x = Math.max(player.radius, Math.min(WIDTH - player.radius, player.pos.x));
      player.pos.y = Math.max(player.radius, Math.min(FLOOR - player.radius, player.pos.y));
      player.cool = Math.max(0, player.cool - dt);
      player.heat = Math.max(0, player.heat - dt * player.coolRate);
      player.dash = Math.max(0, player.dash - dt);
    }

    function dashPlayer(player) {
      if (player.heat > 2.7 || player.dash > 0) return;
      player.dash = 0.3;
      player.heat = Math.min(4, player.heat + 0.5);
    }

    function updateShots(state, dt) {
      state.shots = state.shots.filter((shot) => {
        shot.pos.x += shot.vel.x * dt;
        shot.pos.y += shot.vel.y * dt;
        shot.life -= dt;
        return (
          shot.life > 0 &&
          shot.pos.x > -60 &&
          shot.pos.x < WIDTH + 60 &&
          shot.pos.y > -60 &&
          shot.pos.y < HEIGHT + 60
        );
      });
    }

    function updateEnemies(state, dt) {
      const target = state.player.pos;
      state.enemies.forEach((enemy) => {
        let dx = target.x - enemy.pos.x;
        let dy = target.y - enemy.pos.y;
        const len = Math.hypot(dx, dy) || 1;
        dx /= len;
        dy /= len;
        enemy.pos.x += dx * enemy.speed * dt;
        enemy.pos.y += dy * enemy.speed * dt;
        enemy.mood += dt * 3;
      });
    }

    function updateCoins(state, dt) {
      const player = state.player;
      for (let i = state.coins.length - 1; i >= 0; i--) {
        const coin = state.coins[i];
        coin.vel.y += 250 * dt;
        coin.pos.x += coin.vel.x * dt;
        coin.pos.y += coin.vel.y * dt;
        if (coin.pos.y > FLOOR - coin.radius) {
          coin.pos.y = FLOOR - coin.radius;
          coin.vel.y *= -0.25;
          coin.vel.x *= 0.75;
        }
        const dist = Math.hypot(coin.pos.x - player.pos.x, coin.pos.y - player.pos.y);
        if (dist < coin.radius + player.radius) {
          state.coinsBank += coin.value * state.coinBonus;
          state.coins.splice(i, 1);
          continue;
        }
        if (coin.pos.y >= FLOOR - coin.radius && Math.abs(coin.vel.y) < 5) {
          coin.vel.y = 0;
        }
      }
    }

    function spawnEnemy(state) {
      if (state.enemies.length >= MAX_ENEMIES) return;
      state.enemies.push(makeEnemy(state.wave));
    }

    function dropCoins(state, pos) {
      const count = randInt(1, 3);
      for (let i = 0; i < count; i++) {
        state.coins.push(makeCoin(pos));
      }
    }

    function handleCollisions(state, dt) {
      const player = state.player;
      for (let i = state.enemies.length - 1; i >= 0; i--) {
        const enemy = state.enemies[i];
        for (let j = state.shots.length - 1; j >= 0; j--) {
          const shot = state.shots[j];
          const dist = Math.hypot(enemy.pos.x - shot.pos.x, enemy.pos.y - shot.pos.y);
          if (dist < enemy.size + shot.radius) {
            enemy.hp -= shot.damage;
            state.shots.splice(j, 1);
            state.score += 6;
          }
        }
        if (enemy.hp <= 0) {
          state.enemies.splice(i, 1);
          state.score += 30;
          dropCoins(state, enemy.pos);
          continue;
        }
        const touch = Math.hypot(enemy.pos.x - player.pos.x, enemy.pos.y - player.pos.y) < enemy.size + player.radius;
        if (touch) {
          player.health -= 35 * dt;
          player.heat = Math.min(4, player.heat + 0.1 * dt * FPS);
        }
      }
      if (player.health <= 0 && !state.gameOver) {
        state.gameOver = true;
        state.shopActive = false;
      }
    }

    function updateWaves(state, dt) {
      state.spawnTimer -= dt;
      if (state.spawnTimer <= 0) {
        spawnEnemy(state);
        state.spawnTimer = Math.max(0.45, 1.4 - state.wave * 0.08);
      }
      if (state.score > state.wave * 220) {
        state.wave += 1;
        state.player.health = Math.min(state.player.maxHealth, state.player.health + 20);
      }
      state.shopTimer -= dt;
      if (state.shopTimer <= 0 && !state.shopActive) {
        openShop(state);
      }
    }

    function tickNote(state, dt) {
      if (state.shopNoteTimer > 0) {
        state.shopNoteTimer = Math.max(0, state.shopNoteTimer - dt);
        if (state.shopNoteTimer === 0 && !state.shopActive) {
          state.shopMessage = '';
        }
      }
    }

    function openShop(state) {
      state.shopActive = true;
      state.shopMessage = 'shop paused reality';
      state.shopCards = pickShopCards(shopPool, Math.min(5, shopPool.length));
      state.shopNoteTimer = 0;
    }

    function closeShop(state) {
      state.shopActive = false;
      state.shopMessage = '';
      state.shopTimer = randRange(18, 28);
      state.shopCards = [];
      state.shopNoteTimer = 0;
    }

    function pickShopCards(pool, count) {
      const bag = pool.slice();
      const picks = [];
      while (picks.length < count && bag.length) {
        const idx = Math.floor(Math.random() * bag.length);
        picks.push(bag.splice(idx, 1)[0]);
      }
      return picks;
    }

    function buyOption(state, index) {
      if (index >= state.shopCards.length) {
        closeShop(state);
        return;
      }
      const card = state.shopCards[index];
      if (state.coinsBank < card.cost) {
        state.shopMessage = 'not enough coin juice';
        state.shopNoteTimer = 1.6;
        return;
      }
      state.coinsBank -= card.cost;
      applyUpgrade(state, card.effect);
      closeShop(state);
      state.shopMessage = `bought ${card.name}`;
      state.shopNoteTimer = 2.5;
    }

    function applyUpgrade(state, effect) {
      const player = state.player;
      if (effect === 'heatSink') player.coolRate += 0.25;
      else if (effect === 'damage') player.damage += 1;
      else if (effect === 'heal') player.health = Math.min(player.maxHealth, player.health + 35);
      else if (effect === 'maxHealth') {
        player.maxHealth += 15;
        player.health = Math.min(player.maxHealth, player.health + 15);
      } else if (effect === 'speed') player.speed += 45;
      else if (effect === 'fireRate') player.fireDelay = Math.max(0.08, player.fireDelay - 0.02);
      else if (effect === 'coinBonus') state.coinBonus += 1;
    }

    function updateGame(state, dt) {
      movePlayer(state.player, dt);
      if (keys['ShiftLeft'] || keys['ShiftRight']) {
        dashPlayer(state.player);
      }
      const wantsShot = mouse.down || keys['Space'];
      if (wantsShot) {
        const shot = makeShot(state.player, mouse);
        if (shot) state.shots.push(shot);
      }
      updateShots(state, dt);
      updateEnemies(state, dt);
      handleCollisions(state, dt);
      updateCoins(state, dt);
      updateWaves(state, dt);
      tickNote(state, dt);
    }

    function drawBackground() {
      ctx.fillStyle = colors.dark;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = colors.mid;
      ctx.fillRect(0, FLOOR, WIDTH, HEIGHT - FLOOR);
      for (let i = 0; i < 7; i++) {
        const gap = 110;
        const baseX = (i * gap + (i % 2) * 30) % WIDTH;
        const buildingHeight = 120 + ((i * 27) % 180);
        ctx.fillStyle = colors.light;
        ctx.fillRect(baseX, FLOOR - buildingHeight, 70, buildingHeight);
        ctx.fillStyle = '#5a5a78';
        ctx.fillRect(baseX + 15, FLOOR - buildingHeight - 16, 40, 18);
      }
    }

    function drawPlayer() {
      const p = state.player;
      ctx.beginPath();
      ctx.fillStyle = p.dash > 0 ? 'rgb(180,255,255)' : colors.neonBlue;
      ctx.arc(p.pos.x, p.pos.y, p.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.fillStyle = colors.neonPink;
      ctx.arc(p.pos.x, p.pos.y - p.radius + 4, 6, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawEnemies() {
      state.enemies.forEach((enemy) => {
        const tint = Math.min(150, Math.floor(enemy.mood * 20));
        ctx.beginPath();
        ctx.fillStyle = `rgb(${Math.min(255, 120 + tint)}, 40, 60)`;
        ctx.arc(enemy.pos.x, enemy.pos.y, enemy.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.fillStyle = '#000';
        ctx.arc(enemy.pos.x, enemy.pos.y, 4, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawShots() {
      ctx.fillStyle = colors.neonPink;
      state.shots.forEach((shot) => {
        ctx.beginPath();
        ctx.arc(shot.pos.x, shot.pos.y, shot.radius, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawCoins() {
      state.coins.forEach((coin) => {
        ctx.beginPath();
        ctx.fillStyle = colors.coin;
        ctx.arc(coin.pos.x, coin.pos.y, coin.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.fillStyle = '#fff';
        ctx.arc(coin.pos.x, coin.pos.y, 4, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawHud() {
      const p = state.player;
      ctx.fillStyle = 'rgba(55,35,45,1)';
      ctx.fillRect(30, 30, 340, 26);
      ctx.fillStyle = colors.neonPink;
      const hpRatio = Math.min(1, Math.max(0, p.health) / p.maxHealth);
      ctx.fillRect(30, 30, 340 * hpRatio, 26);
      ctx.fillStyle = '#fff';
      ctx.font = '20px "Trebuchet MS", sans-serif';
      ctx.textAlign = 'left';
      const hpLabel = Math.max(0, Math.round(p.health));
      ctx.fillText(`HP ${hpLabel}/${p.maxHealth}`, 40, 50);
      ctx.fillStyle = 'rgb(215,255,200)';
      ctx.fillText(`score ${state.score}`, WIDTH - 230, 50);
      ctx.fillStyle = colors.coin;
      ctx.fillText(`coins ${state.coinsBank}`, WIDTH - 230, 80);
      ctx.fillStyle = 'rgb(200,220,255)';
      ctx.fillText(`wave ${state.wave}`, WIDTH - 230, 110);
      ctx.fillStyle = colors.heat;
      ctx.fillText(`heat ${p.heat.toFixed(1)}/3`, 40, 78);
      if (state.shopMessage) {
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.fillText(state.shopMessage, WIDTH / 2, 30);
        ctx.textAlign = 'left';
      }
    }

    function drawMenu() {
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = colors.neonBlue;
      ctx.font = '54px "Trebuchet MS", sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('LAST HOPE', WIDTH / 2, 180);
      ctx.fillStyle = '#e6e6e6';
      ctx.font = '26px "Trebuchet MS", sans-serif';
      state.dialog.forEach((line, idx) => {
        ctx.fillText(line, WIDTH / 2, 260 + idx * 40);
      });
      ctx.textAlign = 'left';
    }

    function drawGameOver() {
      ctx.fillStyle = 'rgba(5,5,12,0.75)';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = colors.heat;
      ctx.font = '60px "Trebuchet MS", sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('system failure', WIDTH / 2, HEIGHT / 2 - 20);
      ctx.fillStyle = '#fff';
      ctx.font = '28px "Trebuchet MS", sans-serif';
      ctx.fillText('press R to reboot the rebellion', WIDTH / 2, HEIGHT / 2 + 30);
      ctx.textAlign = 'left';
    }

    function drawShop() {
      const cards = state.shopCards;
      const optionCount = cards.length;
      const panelWidth = 520;
      const panelHeight = 70 + optionCount * 60;
      let px = state.player.pos.x - panelWidth / 2;
      px = Math.max(40, Math.min(WIDTH - panelWidth - 40, px));
      let py = Math.max(80, state.player.pos.y - state.player.radius - panelHeight - 20);
      ctx.fillStyle = 'rgba(30,30,40,0.95)';
      ctx.fillRect(px, py, panelWidth, panelHeight);
      ctx.strokeStyle = colors.neonBlue;
      ctx.lineWidth = 3;
      ctx.strokeRect(px, py, panelWidth, panelHeight);
      ctx.fillStyle = '#fff';
      ctx.font = '22px "Trebuchet MS", sans-serif';
      ctx.fillText(`pop-up shop: pick (1-${optionCount}) or skip (${optionCount + 1})`, px + 18, py + 30);
      cards.forEach((card, idx) => {
        const affordable = state.coinsBank >= card.cost;
        ctx.fillStyle = affordable ? 'rgb(200,255,220)' : 'rgb(130,130,130)';
        ctx.fillText(`${idx + 1}) ${card.name} [${card.cost}c]`, px + 24, py + 60 + idx * 60);
        ctx.fillStyle = 'rgb(180,180,200)';
        ctx.font = '18px "Trebuchet MS", sans-serif';
        ctx.fillText(card.desc, px + 32, py + 84 + idx * 60);
        ctx.font = '22px "Trebuchet MS", sans-serif';
      });
      ctx.fillStyle = '#fff';
      ctx.fillText(`${optionCount + 1}) close shop`, px + 24, py + panelHeight - 24);
    }

    function draw() {
      drawBackground();
      drawCoins();
      drawEnemies();
      drawShots();
      drawPlayer();
      drawHud();
      if (state.menu) drawMenu();
      if (state.shopActive) drawShop();
      if (state.gameOver) drawGameOver();
    }

    function resetGame() {
      state = makeState();
    }

    window.addEventListener('keydown', (e) => {
      if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
        e.preventDefault();
      }
      if (!e.repeat) keys[e.code] = true;
      if (e.code === 'Space' && state.menu) {
        state.menu = false;
      }
      if (e.code === 'KeyR') {
        resetGame();
      }
      if (state.shopActive) {
        if (/^[0-9]$/.test(e.key)) {
          const choice = parseInt(e.key, 10);
          if (choice >= 1 && choice <= state.shopCards.length) {
            buyOption(state, choice - 1);
          } else if (choice === state.shopCards.length + 1) {
            closeShop(state);
          }
        }
        if (e.code === 'Enter' || e.code === 'Escape' || e.code === 'NumpadEnter') {
          closeShop(state);
        }
      }
    });

    window.addEventListener('keyup', (e) => {
      keys[e.code] = false;
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * WIDTH;
      mouse.y = ((e.clientY - rect.top) / rect.height) * HEIGHT;
    });

    canvas.addEventListener('mousedown', (e) => {
      mouse.down = true;
      if (state.menu) state.menu = false;
    });

    window.addEventListener('mouseup', () => {
      mouse.down = false;
    });

    canvas.addEventListener('mouseleave', () => {
      mouse.down = false;
    });

    let last = performance.now();
    function loop(now) {
      const dt = Math.min(0.05, (now - last) / 1000);
      last = now;
      if (!state.menu && !state.gameOver && !state.shopActive) {
        updateGame(state, dt);
      }
      draw();
      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
